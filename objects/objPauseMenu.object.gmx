<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprPauseMenuDOS</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2001</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>phase = 0; // 0: increasing the black rectangle's alpha

option = 0;
oldOption = 0;
weaponOffset = 0;
offsetTimer = -1;

// get currently visible weapons
weaponVisibleN = 10;

for (var i = 0; i &lt; weaponVisibleN; i++)
{
    if (global.weapon[0] == i)
    {
        option = i;
        oldOption = i;
    }
}
woption = i;

visibleWeapons = 10;

oldWeapon = global.weapon[0];
resetWeapon = false; // Should we, after exiting the menu, reset our weapon to the weapon that was used before the pause menu was opened?

wtank = 0;
mtank = 0;

retryConfirm = 0;
exitConfirm = 0;
hotBarArrangeMode = false;

playerID = 0;
costumeID = 0;

// Stop charging
with (objMegaman)
{
    playerPalette();
}

// set these here. makes everyone's lives easier.

etankPositionX = 169;
etankPositionY = 61;
wtankPositionX = 9999;
wtankPositionY = 9999;
mtankPositionX = 9999;
mtankPositionY = 9999;

optionsPositionX = 136;
optionsPositionY = 208;
checkPositionX = 158;
checkPositionY = 208;
exitPositionX = 204;
exitPositionY = 208;

arrowTimer = 20;

quickScrollTimer = 0; // 24;

menuSizeX = 0;
menuSizeY = 0;
menuSizeAltX = 0;
menuSizeAltY = 0;
targetMenuSizeX = 11;
targetMenuSizeY = 4;
menuDrawTimer = 0;
menuDrawTimerMax = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Can't control while options menu is open
if (instance_exists(objOptionsMenu))
{
    exit;
}

// do pause menu
switch (phase)
{
    // setup
    case 0:
        phase = 1;
        with(objGlobalControl) showhealth = 0;
        break;
    
    // properly tile the menu
    case 1:
        menuDrawTimer++;
        if(menuDrawTimer &gt;= menuDrawTimerMax)
        {
            menuDrawTimer = 0;
            if(menuSizeX &gt;= targetMenuSizeX &amp;&amp; menuSizeY &gt;= targetMenuSizeY)
            {
                phase = 2;
            }
            else
            {
                if(menuSizeX &lt; targetMenuSizeX) menuSizeX++;
                if(menuSizeY &lt; targetMenuSizeY) menuSizeY++;
            }
        }
        break;
    
    // Idle
    case 2:
        event_user(0); // Moving the selection
        
        // secret exit and menu options
        if(global.keySlide[playerID])
        {
            if(global.keyJumpPressed[playerID]) // options
            {
                instance_create(x, y, objOptionsMenu);
                playSFX(sfxMenuSelect);
                exit;
            }
            else if(global.keyShootPressed[playerID]) // exit
            {
                returnFromLevel();
                playSFX(sfxMenuSelect);
            }
        }
        // Select the weapon/tank
        else if (global.keyJumpPressed[playerID] || global.keyPausePressed[playerID])
        {
            if (option &lt; weaponVisibleN)
            {
                if (instance_exists(objMegaman.vehicle) &amp;&amp; option != 0)
                {
                    if (!objMegaman.vehicle.weaponsAllowed)
                    {
                        playSFX(sfxError);
                        exit;
                    }
                }
                phase = 3;
                
                global.weapon[playerID] = option;
                if(option != oldOption)
                {
                    with(prtPlayerProjectile) instance_destroy();
                }
                playSFX(sfxMenuSelect);
            }
            else if (option == weaponVisibleN + 1) // E-Tank
            {
                if (global.eTanks &amp;&amp; global.playerHealth[playerID] &lt; 28)
                {
                    option = 99; // Nothing selected
                    phase = 5;
                    wtank = 0;
                    mtank = 0;
                    global.eTanks -= 1;
                    eTankTimer = 0;
                    loopSFX(sfxEnergyRestore);
                }
                else
                {
                    playSFX(sfxError);
                }
            }
            else if (option == weaponVisibleN + 2) // W-Tank
            {
                // Check if weapon energy actually needs filling
                var proceed;
                proceed = false;
                for (i = 0; i &lt; weaponVisibleN; i += 1)
                {
                    if (ceil(global.ammo[playerID, global.weaponHotbar[weaponVisible[i]]]) &lt; 28)
                    {
                        proceed = true;
                    }
                }
                
                if (global.wTanks &amp;&amp; proceed)
                {
                    option = 0; // Go back to weapon column
                    phase = 6;
                    mtank = 0;
                    wtank = 1;
                    global.wTanks -= 1;
                    playSFX(sfxMenuSelect);
                }
                else
                {
                    playSFX(sfxError);
                }
            }
            else if (option == weaponVisibleN + 3) // M-Tank
            {
                if (global.mTanks &gt; 0) // Check if health or weapon energy actually needs filling
                {
                    var proceed = false;
                    for (i = 0; i &lt; weaponVisibleN; i += 1)
                    {
                        if (ceil(global.ammo[playerID, global.weaponHotbar[weaponVisible[i]]]) &lt; 28)
                        {
                            proceed = true;
                        }
                    }
                    
                    if (ceil(global.playerHealth[playerID]) &lt; 28)
                    {
                        proceed = true;
                    }
                    
                    if (proceed) // If proceed is still false after the past calculations, it seems there is nothing to fill
                    {
                        option = 99; // Nothing selected
                        phase = 5;
                        mtank = 1;
                        wtank = 0;
                        global.mTanks -= 1;
                        eTankTimer = 0;
                        loopSFX(sfxEnergyRestore);
                    }
                    else
                    {
                        playSFX(sfxError);
                    }
                }
                else
                {
                    playSFX(sfxError);
                }
            }
            else if (option == weaponVisibleN + 4) // Options
            {
                instance_create(x, y, objOptionsMenu);
                playSFX(sfxMenuSelect);
                exit;
            }
            else if (option == weaponVisibleN + 5) // Retry
            {
                if (!retryConfirm)
                {
                    retryConfirm = true;
                    playSFX(sfxMenuSelect);
                    exit;
                }
            }
            else if (option == weaponVisibleN + 6) // Exit
            {
                if (!exitConfirm)
                {
                    exitConfirm = true;
                    playSFX(sfxMenuSelect);
                    exit;
                }
            }
        }
        
        
        // Confirming exit
        if (exitConfirm &amp;&amp; !global.nextRoom)
        {
            if (option == weaponVisibleN + 6)
            {
                if (global.keyJumpPressed[playerID]
                    || global.keyPausePressed[playerID])
                {
                    returnFromLevel();
                    playSFX(sfxMenuSelect);
                }
            }
            else
            {
                exitConfirm = false;
            }
        }
        
        // Confirming retry
        if (retryConfirm &amp;&amp; !global.nextRoom)
        {
            if (option == weaponVisibleN + 5)
            {
                if (global.keyJumpPressed[playerID]
                    || global.keyPausePressed[playerID])
                {
                    global.nextRoom = room;
                    playSFX(sfxMenuSelect);
                }
            }
            else
            {
                retryConfirm = false;
            }
        }
        
        break;
    
    // Fading out
    case 3:
        menuDrawTimer++;
        if(menuDrawTimer &gt;= menuDrawTimerMax)
        {
            menuDrawTimer = 0;
            if(menuSizeAltX &gt;= targetMenuSizeX &amp;&amp; menuSizeAltY &gt;= targetMenuSizeY)
            {
                with(objGlobalControl) showhealth = 1;
                if (resetWeapon)
                {
                    global.weapon[playerID] = oldWeapon;
                    with (objMegaman)
                    {
                        playerPalette();
                    }
                }
                audio_resume_all();
                instance_destroy();
                global.frozen = 0;
            }
            else
            {
                if(menuSizeAltX &lt; targetMenuSizeX) menuSizeAltX++;
                if(menuSizeAltY &lt; targetMenuSizeY) menuSizeAltY++;
            }
        }
        
        // weapon switch animation a la MM1/2
        with (objMegaman)
        {
            spriteX = 10+clamp(other.menuSizeAltX*2/other.targetMenuSizeX,0,2);
            spriteY = 8;
        }
        break;
    
    // E/M-Tank restoring health
    case 5:
        eTankTimer += 1;
        if (eTankTimer &gt;= 3)
        {
            eTankTimer = 0;
            
            var proceed;
            proceed = false;
            
            // Fill selected weapon w/ W Tank
            if (wtank)
            {
                if (global.ammo[playerID, global.weaponHotbar[weaponVisible[option]]] &lt; 28)
                {
                    global.ammo[playerID, global.weaponHotbar[weaponVisible[option]]] = min(28,
                        global.ammo[playerID, global.weaponHotbar[weaponVisible[option]]] + 1);
                    proceed = true;
                }
            }
            
            // Fill all weapons - M-Tank only
            if (mtank)
            {
                for (i = 1; i &lt; weaponVisibleN; i += 1)
                {
                    if (global.ammo[playerID, global.weaponHotbar[weaponVisible[i]]] &lt; 28)
                    {
                        global.ammo[playerID, global.weaponHotbar[weaponVisible[i]]] = min(28,
                            global.ammo[playerID, global.weaponHotbar[weaponVisible[i]]] + 1);
                        proceed = true;
                    }
                }
            }
            
            // Fill health
            if ((global.playerHealth[playerID] &lt; 28) &amp;&amp; (!wtank))
            {
                global.playerHealth[playerID] = min(28,
                    global.playerHealth[playerID] + 1);
                proceed = true;
            }
            
            if (!proceed)
            {
                eTankTimer = 0;
                phase = 2;
                if (!wtank)
                {
                    option = oldOption;
                    global.weapon[playerID] = oldWeapon;
                    with (objMegaman)
                    {
                        playerPalette();
                    }
                }
                
                audio_stop_sound(sfxEnergyRestore);
            }
        }
        
        break;
    
    // W-Tank weapon selection
    case 6:
        event_user(0); // Moving the selection
        
        if (option &gt; 0 &amp;&amp; option &lt; weaponVisibleN)
        {
            if (global.keyJumpPressed[playerID] || global.keyPausePressed[playerID])
            {
                if (global.ammo[playerID, global.weaponHotbar[weaponVisible[option]]] &lt; 28)
                {
                    phase = 5;
                    eTankTimer = 0;
                    loopSFX(sfxEnergyRestore);
                }
                else
                {
                    playSFX(sfxError);
                }
            }
        }
        
        break;
}

// update stored player sprite
if (instance_exists(objMegaman))
{
    with (objMegaman)
    {
        if (playerID == other.playerID)
        {
            other.costumeID = costumeID;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>hotBarArrangeMode = false;//(global.keyShoot[playerID]) * (hotBarArrangeMode + 1);

var xDir = (global.keyRightPressed[playerID] - global.keyLeftPressed[playerID]);

var yDir = (global.keyDownPressed[playerID] - global.keyUpPressed[playerID]);

if (xDir != 0)
{
    // get all possible moves
    var prevOption = option;
    var safetyExit = 30;
    var keepGoing = true;
    
    do
    {
        option += xDir;
        if(option &lt; 0)
        {
            if(global.eTanks) option = weaponVisibleN+1;
            else option = weaponVisibleN-1;
        }
        else if(option == weaponVisibleN)
        {
            if(xDir &gt; 0)
            {
                if(global.eTanks) option = weaponVisibleN+1;
                else option = 0;
            }
            else option = weaponVisibleN-1;
        }
        else if(option &gt;= weaponVisibleN+1)
        {
            if(xDir &gt; 0)
            {
                option = 0;
            }
            else option = weaponVisibleN-1;
        }
        
        safetyExit--;
        if(!safetyExit)
        {
            option = 0;
        }
        
        if(option == clamp(option,0,9) &amp;&amp; !global.weaponLocked[option])
        {
            keepGoing = false;
        }
        
        if(option == weaponVisibleN+1 &amp;&amp; global.eTanks)
        {
            keepGoing = false;
        }
    }
    until(!keepGoing);
    
    if(prevOption != option) playSFX(sfxMenuMove);
}

if (yDir != 0)
{
    var prevOption = option;
    if(global.eTanks)
    {
        if(option == weaponVisibleN+1) option = 0;
        else option = weaponVisibleN+1;
    }
    else option = 0;
    
    if(prevOption != option) playSFX(sfxMenuMove);
}

// Set weapon
global.weapon[playerID] = 0;
if(option &lt; 0) option = 0;
if (option &lt; weaponVisibleN)
{
    global.weapon[playerID] = option;
}

with (objMegaman)
{
    playerPalette();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// set correct position
x = view_xview + 24;
y = view_yview + 64;

// Menu
if (phase != 0)
{
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    draw_set_color(c_white);
    
    var col;
    col[0, 0] = global.nesPalette[0];
    col[1, 0] = global.nesPalette[13];
    col[0, 1] = global.primaryCol[0];
    col[1, 1] = global.secondaryCol[0];
    col[0, 2] = make_color_rgb(255, 228, 164);
    col[1, 2] = c_white;
    
    // tile the menu
    // the origin is top left corner
    draw_sprite(sprite_index,0,x+16*menuSizeAltX,y+16*menuSizeAltY);
    // top edge
    for(var i = menuSizeAltX; i &lt; menuSizeX; i++)
    {
        draw_sprite(sprite_index,1,x+16+i*16,y+16*menuSizeAltY);
    }
    // top right corner
    draw_sprite(sprite_index,2,x+16+menuSizeX*16,y+16*menuSizeAltY);
    // body
    for(var j = menuSizeAltY; j &lt; menuSizeY; j++)
    {
        // left edge
        draw_sprite(sprite_index,3,x+16*menuSizeAltX,y+16+j*16);
        // center
        for(var i = menuSizeAltX; i &lt; menuSizeX; i++)
        {
            draw_sprite(sprite_index,4,x+16+i*16,y+16+j*16);
        }
        // right edge
        draw_sprite(sprite_index,5,x+16+menuSizeX*16,y+16+j*16);
    }
    // bottom left corner
    draw_sprite(sprite_index,6,x+16*menuSizeAltX,y+16+menuSizeY*16);
    // bottom edge
    for(var i = menuSizeAltX; i &lt; menuSizeX; i++)
    {
        draw_sprite(sprite_index,7,x+16+i*16,y+16+menuSizeY*16);
    }
    // bottom right corner
    draw_sprite(sprite_index,8,x+16+menuSizeX*16,y+16+menuSizeY*16);
    
    // Icons, ammo bars and names
    if(menuSizeX - menuSizeAltX == targetMenuSizeX)
    {
        for(var i = 0; i &lt; 10; i++)
        {
            var w = i;
            var cl = (option == i);
            
            if(!global.weaponLocked[w])
            {
                // letters
                draw_sprite_ext(sprDOSletter,i,x+10+i*16,y+10,1,1,0,col[cl, cl*2],1);
                
                // Drawing ammo bars
                ammo = round(global.playerHealth[playerID] * (i == 0) + global.ammo[playerID, w] * (i != 0));
                
                draw_sprite_ext(sprHealthbarBackground, 0, x+12+i*16, y+26, 1, 1, 0, c_black, 1);
                for(var z = 0; z &lt; ammo; z++) draw_sprite_ext(sprHealthbarPrimary, 0, x+12+i*16+1, y+26+54-z*2, 1, 1, 0, col[0, cl * (1 + (i == 0))], 1);
                for(var z = 0; z &lt; ammo; z++) draw_sprite_ext(sprHealthbarSecondary, 0, x+12+i*16+1, y+26+54-z*2, 1, 1, 0, col[1, cl * (1 + (i == 0))], 1);
            }
        }
        
        // lives remaining
        with (objMegaman)
        {
            if (playerID == other.playerID)
            {
                drawPlayer(playerID, costumeID, 16, 12, other.x + 169+8, other.y + 29, 1, 1);
            }
        }
        
        var livesText = clamp(global.livesRemaining,0,9);
        if (!global.livesEnabled)
        {
            livesText = 9;
        }
        
        draw_sprite_ext(sprDOSnum, livesText, x + etankPositionX + 17, y + etankPositionY + 2 - 32, 1, 1, 0, c_white, 1);
        
        // E-Tank
        draw_sprite_ext(sprETank, 0, x + etankPositionX, y + etankPositionY, 1, 1, 0, c_white, 1);
        draw_sprite_ext(sprETank, 2, x + etankPositionX, y + etankPositionY, 1, 1, 0, col[0, option == weaponVisibleN+1], 1);
        draw_sprite_ext(sprETank, 4, x + etankPositionX, y + etankPositionY, 1, 1, 0, col[1, option == weaponVisibleN+1], 1);
        draw_sprite_ext(sprETank, 6, x + etankPositionX, y + etankPositionY, 1, 1, 0, c_black, 1);
        
        var tankCount = clamp(global.eTanks,0,9);
        draw_sprite_ext(sprDOSnum, tankCount, x + etankPositionX + 17, y + etankPositionY + 2, 1, 1, 0, col[option == weaponVisibleN+1, (option == weaponVisibleN+1)*2], 1);
    }
    
    draw_set_halign(fa_center);
    
    // secret options
    draw_text(view_xview+view_wview/2,view_yview+view_hview-64,"SLIDE+JUMP for options");
    draw_text(view_xview+view_wview/2,view_yview+view_hview-64+10,"SLIDE+SHOOT to exit");
    
    // colored text overlays
    if (global.showColoredTextOverlays)
    {
        draw_sprite_ext(sprDot, 0, x, y, 16*(2+menuSizeX-menuSizeAltX), 16*(2+menuSizeY-menuSizeAltY), 0,
            make_color_rgb(global.coloredTextOverlaysRed, global.coloredTextOverlaysGreen, global.coloredTextOverlaysBlue),
            global.coloredTextOverlaysOpacity / 255);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
