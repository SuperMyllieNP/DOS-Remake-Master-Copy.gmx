<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprDOSmenuTiles</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2001</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>phase = 0; // 0: increasing the black rectangle's alpha

option = 0;
oldOption = 0;
weaponOffset = 0;
offsetTimer = -1;

// get currently visible weapons
weaponVisibleN = 0;
for (var i = 0; i &lt;= global.totalWeapons; i++)
{
    if (global.weaponLocked[global.weaponHotbar[i]] &lt; 2)
    {
        weaponVisible[weaponVisibleN++] = i;
    }
}
visibleWeapons = min(10, weaponVisibleN); // up to 10 visible

for (var i = 0; i &lt; weaponVisibleN; i++)
{
    if (global.weapon[0] == global.weaponHotbar[weaponVisible[i]])
    {
        option = i;
        oldOption = i;
    }
}
woption = i;

oldWeapon = global.weapon[0];
resetWeapon = false; // Should we, after exiting the menu, reset our weapon to the weapon that was used before the pause menu was opened?

wtank = 0;
mtank = 0;

retryConfirm = 0;
exitConfirm = 0;
hotBarArrangeMode = false;

playerID = 0;
costumeID = 0;
parent = noone;

saveChargeTimer = 0;
saveInitChargeTimer = 0;

// Stop charging
with (objMegaman)
{
    other.saveChargeTimer = chargeTimer;
    other.saveInitChargeTimer = initChargeTimer;
    playerPalette();
}

// set these here. makes everyone's lives easier.

etankPositionX = 161;
etankPositionY = 52;
wtankPositionX = 178;
wtankPositionY = 10;
mtankPositionX = 210;
mtankPositionY = 10;

optionsPositionX = 0;
optionsPositionY = 104;
checkPositionX = 96;
checkPositionY = 104;
exitPositionX = 192;
exitPositionY = 104;

arrowTimer = 20;

quickScrollTimer = 0; // 24;

drawMenuSizeBegin = 0;
drawMenuSizeEnd = 0;
fadeTimer = 0;
fadeTimerMax = 0;
menuSizeCapX = 12;
menuSizeCapY = 5;

menuPosX = 32;
menuPosY = 72;

storePlayerSpriteX = 0;
storePlayerSpriteY = 0;

playerAnimTimer = 0;

previousOption = 0;

letterMap[0] = "0";
letterMap[1] = "1";
letterMap[2] = "2";
letterMap[3] = "3";
letterMap[4] = "4";
letterMap[5] = "5";
letterMap[6] = "6";
letterMap[7] = "7";
letterMap[8] = "8";
letterMap[9] = "9";
letterMap[10] = "P";
letterMap[11] = "D";
letterMap[12] = "N";
letterMap[13] = "V";
letterMap[14] = "B";
letterMap[15] = "S";
letterMap[16] = "W";
letterMap[17] = "O";
letterMap[18] = "L";
letterMap[19] = "T";

allowExtraOptions = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Can't control while options menu is open
if (instance_exists(objOptionsMenu))
{
    exit;
}

// do pause menu
switch (phase)
{
    // Fading out
    case 0:
        phase = 1;
        drawMenuSizeBegin = 0;
        drawMenuSizeEnd = 0;
        fadeTimer = 0;
        playerAnimTimer = 0;
        with(objMegaman) if(playerID == other.playerID)
        {
            other.storePlayerSpriteX = spriteX;
            other.storePlayerSpriteY = spriteY;
            other.parent = self;
        }
        with(objGlobalControl) showhealth = 0;
        break;
    
    // Fading in
    case 1:
        fadeTimer++;
        if(fadeTimer &gt; fadeTimerMax)
        {
            fadeTimer = 0;
            drawMenuSizeEnd++;
        }
        if(drawMenuSizeEnd &gt;= max(menuSizeCapX,menuSizeCapY))
        {
            drawMenuSizeEnd = max(menuSizeCapX,menuSizeCapY);
            phase = 2;
        }
        break;
    
    // Idle
    case 2:
        event_user(0); // Moving the selection
        
        // Select the weapon
        if (global.keyJumpPressed[playerID] || global.keyPausePressed[playerID])
        {
            if(option &lt; weaponVisibleN)
            {
                global.weapon[playerID] = global.weaponHotbar[weaponVisible[option]];
                playSFX(sfxMenuSelect);
                phase = 3;
            }
            else 
            {
                if(option == weaponVisibleN+1)
                {
                    if (global.eTanks &amp;&amp; global.playerHealth[playerID] &lt; 28)
                    {
                        option = 99; // nothing selected
                        phase = 5;
                        wtank = 0;
                        mtank = 0;
                        global.eTanks -= 1;
                        eTankTimer = 0;
                        loopSFX(sfxEnergyRestore);
                    }
                    else
                    {
                        playSFX(sfxError);
                    }
                }
                else if (option == weaponVisibleN + 4) // Options
                {
                    instance_create(x, y, objOptionsMenu);
                    playSFX(sfxMenuSelect);
                    exit;
                }
                else if (option == weaponVisibleN + 5) // Retry
                {
                    if (!retryConfirm)
                    {
                        retryConfirm = true;
                        playSFX(sfxMenuSelect);
                        exit;
                    }
                }
                else if (option == weaponVisibleN + 6) // Exit
                {
                    if (!exitConfirm)
                    {
                        exitConfirm = true;
                        playSFX(sfxMenuSelect);
                        exit;
                    }
                }
            }
        }
        
        // Confirming exit
        if (exitConfirm &amp;&amp; !global.nextRoom)
        {
            if (option == weaponVisibleN + 6)
            {
                if (global.keyJumpPressed[playerID]
                    || global.keyPausePressed[playerID])
                {
                    returnFromLevel();
                    playSFX(sfxMenuSelect);
                }
            }
            else
            {
                exitConfirm = false;
            }
        }
        
        // Confirming retry
        if (retryConfirm &amp;&amp; !global.nextRoom)
        {
            if (option == weaponVisibleN + 5)
            {
                if (global.keyJumpPressed[playerID]
                    || global.keyPausePressed[playerID])
                {
                    global.nextRoom = room;
                    playSFX(sfxMenuSelect);
                }
            }
            else
            {
                retryConfirm = false;
            }
        }
        /*
        event_user(0); // Moving the selection
        
        // Select the weapon/tank
        if (global.keyJumpPressed[playerID] || global.keyPausePressed[playerID])
        {
            if (option &lt;= weaponVisibleN)
            {
                if (instance_exists(objMegaman.vehicle) &amp;&amp; option != 0)
                {
                    if (!objMegaman.vehicle.weaponsAllowed)
                    {
                        playSFX(sfxError);
                        exit;
                    }
                }
                
                global.nextRoom = -1;
                phase = 3;
                
                global.weapon[playerID] = global.weaponHotbar[weaponVisible[option]];
                playSFX(sfxMenuSelect);
            }
            else if (option == weaponVisibleN + 1) // E-Tank
            {
                if (global.eTanks &amp;&amp; global.playerHealth[playerID] &lt; 28)
                {
                    option = 99; // Nothing selected
                    phase = 5;
                    wtank = 0;
                    mtank = 0;
                    global.eTanks -= 1;
                    eTankTimer = 0;
                    loopSFX(sfxEnergyRestore);
                }
                else
                {
                    playSFX(sfxError);
                }
            }
            else if (option == weaponVisibleN + 2) // W-Tank
            {
                // Check if weapon energy actually needs filling
                var proceed;
                proceed = false;
                for (i = 0; i &lt; weaponVisibleN; i += 1)
                {
                    if (ceil(global.ammo[playerID, global.weaponHotbar[weaponVisible[i]]]) &lt; 28)
                    {
                        proceed = true;
                    }
                }
                
                if (global.wTanks &amp;&amp; proceed)
                {
                    option = 0; // Go back to weapon column
                    phase = 6;
                    mtank = 0;
                    wtank = 1;
                    global.wTanks -= 1;
                    playSFX(sfxMenuSelect);
                }
                else
                {
                    playSFX(sfxError);
                }
            }
            else if (option == weaponVisibleN + 3) // M-Tank
            {
                if (global.mTanks &gt; 0) // Check if health or weapon energy actually needs filling
                {
                    var proceed = false;
                    for (i = 0; i &lt; weaponVisibleN; i += 1)
                    {
                        if (ceil(global.ammo[playerID, global.weaponHotbar[weaponVisible[i]]]) &lt; 28)
                        {
                            proceed = true;
                        }
                    }
                    
                    if (ceil(global.playerHealth[playerID]) &lt; 28)
                    {
                        proceed = true;
                    }
                    
                    if (proceed) // If proceed is still false after the past calculations, it seems there is nothing to fill
                    {
                        option = 99; // Nothing selected
                        phase = 5;
                        mtank = 1;
                        wtank = 0;
                        global.mTanks -= 1;
                        eTankTimer = 0;
                        loopSFX(sfxEnergyRestore);
                    }
                    else
                    {
                        playSFX(sfxError);
                    }
                }
                else
                {
                    playSFX(sfxError);
                }
            }
        }
        */
        break;
    
    // Fading out
    case 3:
        if (resetWeapon)
        {
            global.weapon[playerID] = oldWeapon;
            with (objMegaman)
            {
                playerPalette();
            }
        }
                    
        if (global.weapon[playerID] != oldWeapon)
        {
            with (prtPlayerProjectile)
            {
                instance_destroy();
            }
        }
        
        if(!parent)
        {
            instance_destroy();
            exit;
        }
        
        // weapon switch animation like in MM1/2
        playerAnimTimer++;
        if(playerAnimTimer &lt; 4)
        {
            parent.spriteX = 10;
            parent.spriteY = 8;
        }
        else if(playerAnimTimer &lt; 8)
        {
            parent.spriteX = 11;
            parent.spriteY = 8;
        }
        else if(playerAnimTimer &lt; 12)
        {
            parent.spriteX = 12;
            parent.spriteY = 8;
        }
        else
        {
            parent.spriteX = storePlayerSpriteX;
            parent.spriteY = storePlayerSpriteY;
        }
        
        fadeTimer++;
        if(fadeTimer &gt; fadeTimerMax)
        {
            fadeTimer = 0;
            drawMenuSizeBegin++;
        }
        if(drawMenuSizeBegin &gt;= max(menuSizeCapX,menuSizeCapY))
        {
            drawMenuSizeBegin = max(menuSizeCapX,menuSizeCapY);
            audio_resume_all();
            instance_destroy();
            global.frozen = 0;
            with(objGlobalControl) showhealth = 1;
            with(parent)
            {
                chargeTimer = other.saveChargeTimer;
                initChargeTimer = other.saveInitChargeTimer;
            }
        }
        
        break;
    
    // E/M-Tank restoring health
    case 5:
        eTankTimer += 1;
        if (eTankTimer &gt;= 3)
        {
            eTankTimer = 0;
            
            var proceed;
            proceed = false;
            
            // Fill selected weapon w/ W Tank
            if (wtank)
            {
                if (global.ammo[playerID, global.weaponHotbar[weaponVisible[option]]] &lt; 28)
                {
                    global.ammo[playerID, global.weaponHotbar[weaponVisible[option]]] = min(28,
                        global.ammo[playerID, global.weaponHotbar[weaponVisible[option]]] + 1);
                    proceed = true;
                }
            }
            
            // Fill all weapons - M-Tank only
            if (mtank)
            {
                for (i = 1; i &lt; weaponVisibleN; i += 1)
                {
                    if (global.ammo[playerID, global.weaponHotbar[weaponVisible[i]]] &lt; 28)
                    {
                        global.ammo[playerID, global.weaponHotbar[weaponVisible[i]]] = min(28,
                            global.ammo[playerID, global.weaponHotbar[weaponVisible[i]]] + 1);
                        proceed = true;
                    }
                }
            }
            
            // Fill health
            if ((global.playerHealth[playerID] &lt; 28) &amp;&amp; (!wtank))
            {
                global.playerHealth[playerID] = min(28,
                    global.playerHealth[playerID] + 1);
                proceed = true;
            }
            
            if (!proceed)
            {
                eTankTimer = 0;
                phase = 2;
                if (!wtank)
                {
                    option = oldOption;
                    global.weapon[playerID] = oldWeapon;
                    with (objMegaman)
                    {
                        playerPalette();
                    }
                }
                
                audio_stop_sound(sfxEnergyRestore);
            }
        }
        
        break;
    
    // W-Tank weapon selection
    case 6:
        event_user(0); // Moving the selection
        
        if (option &gt; 0 &amp;&amp; option &lt; weaponVisibleN)
        {
            if (global.keyJumpPressed[playerID] || global.keyPausePressed[playerID])
            {
                if (global.ammo[playerID, global.weaponHotbar[weaponVisible[option]]] &lt; 28)
                {
                    phase = 5;
                    eTankTimer = 0;
                    loopSFX(sfxEnergyRestore);
                }
                else
                {
                    playSFX(sfxError);
                }
            }
        }
        
        break;
}

// update stored player sprite
if (instance_exists(objMegaman))
{
    with (objMegaman)
    {
        if (playerID == other.playerID)
        {
            other.costumeID = costumeID;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// pause menu control

hotBarArrangeMode = (global.keyShoot[playerID]) * (hotBarArrangeMode + 1);

var xDir = (global.keyRightPressed[playerID] - global.keyLeftPressed[playerID]);
var yDir = (global.keyDownPressed[playerID] - global.keyUpPressed[playerID]);
/*
var yDir = ((global.keyDownPressed[playerID] || (global.keyDown[playerID] &amp;&amp; quickScrollTimer &lt;= 0))
    - (global.keyUpPressed[playerID] || (global.keyUp[playerID] &amp;&amp; quickScrollTimer &lt;= 0)));
*/

if (xDir != 0)
{
    playSFX(sfxMenuMove);
    
    if (option &lt; weaponVisibleN)
    {
        woption = option;
        
        if (hotBarArrangeMode) // swap weapons:
        {
            if (option + xDir &lt; weaponVisibleN &amp;&amp; option + min(xDir, 0) &gt;= 1)
            {
                option += xDir;
                swap(global.weaponHotbar, weaponVisible[option], weaponVisible[option - xDir]);
            }
        }
        else
        {
            var emergencyRetryCount = 0;
            while(emergencyRetryCount == 0 || (emergencyRetryCount &lt; 30 &amp;&amp; option &gt;= 0 &amp;&amp; option &lt; weaponVisibleN &amp;&amp; (global.weaponLocked[global.weaponHotbar[weaponVisible[option]]])))
            {
                emergencyRetryCount++;
                option += xDir;
                if (option &gt;= weaponVisibleN)
                {
                    if(global.eTanks &gt; 0)
                    {
                        previousOption = option;
                        option = weaponVisibleN+1;
                    }
                    else option = 0;
                }
                else if (option &lt; 0)
                {
                    if(global.eTanks &gt; 0)
                    {
                        previousOption = option;
                        option = weaponVisibleN+1;
                    }
                    else option = weaponVisibleN - 1;
                }
            }
            
            if(emergencyRetryCount &gt;= 30)
            {
                option = 0;
            }
        }
    }
    else
    {
        if(allowExtraOptions &amp;&amp; option &gt;= weaponVisibleN+4)
        {
            option += xDir;
            if(option &lt; weaponVisibleN+4) option = weaponVisibleN+6;
            else if(option &gt; weaponVisibleN+6) option = weaponVisibleN+4;
        }
        else
        {
            if(xDir &gt; 0) option = 0;
            else option = weaponVisibleN - 1;
        }
    }
}
else if (yDir != 0)
{
    playSFX(sfxMenuMove);
    
    if(allowExtraOptions &amp;&amp; option &lt; weaponVisibleN+4)
    {
        option = weaponVisibleN+4;
    }
    else
    {
        if(yDir &gt; 0)
        {
            if(option == weaponVisibleN - 1 + 2*(global.eTanks &gt; 0)) option = 0;
            else option = weaponVisibleN - 1 + 2*(global.eTanks &gt; 0);
        }
        else
        {
            if(option == 0) option = weaponVisibleN - 1 + 2*(global.eTanks &gt; 0);
            else option = 0;
        }
    }
}

/*
if (xDir != 0 &amp;&amp; phase != 6)
{
    playSFX(sfxMenuMove);
    
    if (option &lt; weaponVisibleN) // horizontal movements while on the weapon list
    {
        option = weaponVisibleN + 2 - xDir;
    }
    else // horizontal movements while on the misc selections
    {
        if ((option == weaponVisibleN + 1 &amp;&amp; xDir &lt; 0) // loop back to weapon list
        || (option == weaponVisibleN + 3 &amp;&amp; xDir &gt; 0)
            || (option == weaponVisibleN + 4 &amp;&amp; xDir &lt; 0)
            || (option == weaponVisibleN + 6 &amp;&amp; xDir &gt; 0))
        {
            option = 0;
        }
        else
        {
            option += xDir;
        }
    }
}

// do quick scroll timer
if ((global.keyDown[playerID] &amp;&amp; option &lt; weaponVisibleN - 1)
    - (global.keyUp[playerID] &amp;&amp; option) != 0)
{
    if (quickScrollTimer &lt;= 0) // slight pause between scrolls
    {
        quickScrollTimer = 6; // &lt;-- time until quick scroll here
    }
    
    quickScrollTimer--;
}
else
{
    quickScrollTimer = 24; // &lt;-- time until quick scroll here
}
*/

// L + R resets weapon order

// it only checks for one pressed because if it checked both you'd have to press both
// buttons on the same frame, but if you could just hold the two buttons you would get
// a very loud screeching noise every time you reset + it'd be easier to accidentally
// sort
if ((global.keyWeaponSwitchLeft[playerID] &amp;&amp; global.keyWeaponSwitchRightPressed[playerID])
    || (global.keyWeaponSwitchLeftPressed[playerID] &amp;&amp; global.keyWeaponSwitchRight[playerID]))
{
    for (var i = 0; i &lt;= global.totalWeapons; i++)
    {
        if global.weaponHotbar[i] != i
        {
            global.weaponHotbar[i] = i;
            playSFX(sfxMenuSelect);
        }
    }
    
    weaponVisibleN = 0;
    for (var i = 0; i &lt;= global.totalWeapons; i++)
    {
        if (global.weaponLocked[global.weaponHotbar[i]] &lt; 2)
        {
            weaponVisible[weaponVisibleN++] = i;
        }
    }
    visibleWeapons = min(10, weaponVisibleN); // up to 10 visible
    oldOption = 0;
}


// Set weapon
global.weapon[playerID] = 0;
if (option &lt; weaponVisibleN)
{
    global.weapon[playerID] = global.weaponHotbar[weaponVisible[option]];
}

with (objMegaman)
{
    playerPalette();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// center in screen on nonstandard resolutions
x = view_xview + (view_wview[0] - 256) / 2;
y = view_yview + (view_hview[0] - 224) / 2;

// Menu
if (phase != 0)
{
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    draw_set_color(c_white);
    
    var col;
    col[0, 0] = global.nesPalette[0];
    col[1, 0] = global.nesPalette[13];
    col[0, 1] = global.primaryCol[0];
    col[1, 1] = global.secondaryCol[0];
    col[0, 2] = make_color_rgb(255, 228, 164);
    col[1, 2] = c_white;
    
    if (option &lt; weaponVisibleN)
    {
        weaponOffset = clamp(option - floor(visibleWeapons * 0.5), 0, weaponVisibleN - visibleWeapons);
    }
    
    if (abs(weaponOffset - offsetTimer) &lt; 0.05 || offsetTimer &lt; 0)
    {
        offsetTimer = weaponOffset;
    }
    offsetTimer += (weaponOffset - offsetTimer) / 8;
    
    draw_set_color(c_white);
    if(allowExtraOptions)
    {
        draw_set_valign(fa_center);
        draw_set_halign(fa_center);
        
        // Options
        if(option == weaponVisibleN + 4) draw_set_color(col[0, 2]);
        draw_text(view_xview+menuPosX+optionsPositionX,view_yview+menuPosY+optionsPositionY,"OPTIONS");
        draw_set_color(c_white);
        
        // Checkpoint
        if(option == weaponVisibleN + 5) draw_set_color(col[0, 2]);
        draw_text(view_xview+menuPosX+checkPositionX,view_yview+menuPosY+checkPositionY,"RETRY");
        draw_set_color(c_white);
        
        // Exit
        if(option == weaponVisibleN + 6) draw_set_color(col[0, 2]);
        draw_text(view_xview+menuPosX+exitPositionX,view_yview+menuPosY+exitPositionY,"EXIT");
        draw_set_color(c_white);
        
        if(exitConfirm)
            draw_text(view_xview+menuPosX+checkPositionX,view_yview+menuPosY+checkPositionY+10,"EXIT LEVEL?")
        else if(retryConfirm)
            draw_text(view_xview+menuPosX+checkPositionX,view_yview+menuPosY+checkPositionY+10,"RETRY FROM CHECKPOINT?")
    }
    draw_set_color(c_white);
    
    // NOW draw itself
    // top left corner
    draw_sprite(sprite_index,0,view_xview+menuPosX+min(drawMenuSizeBegin,menuSizeCapX)*16-16,view_yview+menuPosY+min(drawMenuSizeBegin,menuSizeCapY)*16-16);
    
    // top border
    for(var i = drawMenuSizeBegin; i &lt; min(menuSizeCapX,drawMenuSizeEnd); i++)
    {
        draw_sprite(sprite_index,1,view_xview+menuPosX+i*16,view_yview+menuPosY+min(menuSizeCapY,drawMenuSizeBegin)*16-16);
    }
    
    // top right corner
    draw_sprite(sprite_index,2,view_xview+menuPosX+min(drawMenuSizeEnd,menuSizeCapX)*16,view_yview+menuPosY+min(drawMenuSizeBegin,menuSizeCapY)*16-16);
    
    // left border
    for(var j = drawMenuSizeBegin; j &lt; min(menuSizeCapY,drawMenuSizeEnd); j++)
    {
        draw_sprite(sprite_index,3,view_xview+menuPosX+min(drawMenuSizeBegin,menuSizeCapX)*16-16,view_yview+menuPosY+j*16);
    }
    
    // fill
    for(var i = drawMenuSizeBegin; i &lt; min(menuSizeCapX,drawMenuSizeEnd); i++)
    {
        for(var j = drawMenuSizeBegin; j &lt; min(menuSizeCapY,drawMenuSizeEnd); j++)
        {
            draw_sprite(sprite_index,4,view_xview+menuPosX+i*16,view_yview+menuPosY+j*16);
        }
    }
    
    // right border
    for(var j = drawMenuSizeBegin; j &lt; min(menuSizeCapY,drawMenuSizeEnd); j++)
    {
        draw_sprite(sprite_index,5,view_xview+menuPosX+min(drawMenuSizeEnd,menuSizeCapX)*16,view_yview+menuPosY+j*16);
    }
    
    // bottom left corner
    draw_sprite(sprite_index,6,view_xview+menuPosX+min(drawMenuSizeBegin,menuSizeCapX)*16-16,view_yview+menuPosY+min(drawMenuSizeEnd,menuSizeCapY)*16);
    
    // bottom border
    for(var i = drawMenuSizeBegin; i &lt; min(menuSizeCapX,drawMenuSizeEnd); i++)
    {
        draw_sprite(sprite_index,7,view_xview+menuPosX+i*16,view_yview+menuPosY+min(drawMenuSizeEnd,menuSizeCapY)*16);
    }
    
    // bottom right corner
    draw_sprite(sprite_index,8,view_xview+menuPosX+min(drawMenuSizeEnd,menuSizeCapX)*16,view_yview+menuPosY+min(drawMenuSizeEnd,menuSizeCapY)*16);
    
    // Icons, ammo bars and names
    // but only when menu is full
    
    if(abs(drawMenuSizeEnd-drawMenuSizeBegin) == max(menuSizeCapX,menuSizeCapY))
    {
        var wSep = 16; // Seperation between icons
        var xOff = -round((offsetTimer mod 1) * wSep);
        
        var surface = surface_create(visibleWeapons*wSep, menuSizeCapY*16);
        surface_set_target(surface);
        draw_clear_alpha(c_white, 0);
        
        draw_set_halign(fa_left);
        for (i = max(0, floor(offsetTimer)); i &lt;= min(ceil(offsetTimer) + visibleWeapons, weaponVisibleN - 1); i++)
        {
            var w = global.weaponHotbar[weaponVisible[i]];
            var cl = (option == i);
            
            // Icon
            if(global.weaponLetter[w] == "")
            {
                draw_sprite_ext(global.weaponIcon[w], 0, xOff, 0, 1, 1, 0, col[!cl, 2], 1);
                draw_sprite_ext(global.weaponIcon[w], 1, xOff, 0, 1, 1, 0, col[0, cl], 1);
                draw_sprite_ext(global.weaponIcon[w], 2, xOff, 0, 1, 1, 0, col[1, cl], 1);
                draw_sprite_ext(global.weaponIcon[w], 3, xOff, 0, 1, 1, 0, col[1, 2], cl);
            }
            // letter
            else
            {
                var num = -1;
                for(var _v = 0; _v &lt; array_length_1d(letterMap); _v++)
                {
                    if(global.weaponLetter[w] == letterMap[_v])
                    {
                        num = _v;
                        _v = array_length_1d(letterMap);
                    }
                }
                if(num &gt; -1) draw_sprite_ext(sprDOSlettersPause,num,xOff+1,1,1,1,0,col[!cl, 2],1);
            }
            
            if (!global.weaponLocked[w] || w == global.weaponID[? objBusterShot])
            {
                // Drawing ammo bars
                ammo = round(global.playerHealth[playerID] * (i == 0) + global.ammo[playerID, w] * (i != 0));
                if(w == global.weaponID[? objBusterShot]) ammo = global.playerHealth[playerID];
                
                draw_sprite_ext(sprDOSpauseBarBG, 2, xOff+1, 16, 1, 1, 0, c_black, 1);
                draw_sprite_ext(sprDOSpauseBarBG, 1, xOff+1, 16, 1, 1, 0, col[1, cl * (1 + (i == 0))], 1);
                draw_sprite_ext(sprDOSpauseBarBG, 0, xOff+1, 16, 1, 1, 0, col[0, cl * (1 + (i == 0))], 1);
                
                for(var _v = 28-ammo; _v &lt; 28; _v++)
                {
                    draw_sprite_ext(sprDOSpauseBar, 0, xOff+4, 20+_v*2, 1, 1, 0, col[0, cl * (1 + (i == 0))], 1);
                    draw_sprite_ext(sprDOSpauseBar, 1, xOff+4, 20+_v*2, 1, 1, 0, col[1, cl * (1 + (i == 0))], 1);
                }
                
                /*
                // Draw infinite energy mark over relevant bars
                if (global.infiniteEnergy[w])
                {
                    draw_sprite_ext(sprInfinityMark, 0, 18 + 28, yOff + 8, 1, 1, 0, c_white, 1);
                    draw_sprite_ext(sprInfinityMark, 1, 18 + 28, yOff + 8, 1, 1, 0, col[0, cl], 1);
                    draw_sprite_ext(sprInfinityMark, 2, 18 + 28, yOff + 8, 1, 1, 0, col[1, cl], 1);
                }
                */
                
                // Name
                draw_set_color(col[!cl, (cl * 2) - (cl * !(hotBarArrangeMode mod 8 &lt; 4))]);
                
                wname = string_copy(global.weaponName[w],1,1);
                
                draw_set_color(c_white);
            }
            
            xOff += wSep;
        }
        
        surface_reset_target();
        draw_surface(surface, view_xview+menuPosX, view_yview+menuPosY);
        surface_free(surface);
        
        // :D
        with (objMegaman)
        {
            if (playerID == other.playerID)
            {
                drawPlayer(playerID, costumeID, 16, 12, other.x + other.menuPosX + 161 + 8, other.y + other.menuPosY + 20, 1, 1);
            }
        }
        
        // lives remaining
        var lifeCount = clamp(global.livesRemaining,0,9);
        if (!global.livesEnabled) lifeCount = 9;
        draw_sprite(sprDOSlettersPause, letterMap[lifeCount], view_xview + menuPosX + 161 + 17, view_yview + menuPosY + 20 + 2);
        
        // E-Tank
        draw_sprite_ext(sprETank, 2, view_xview + menuPosX + etankPositionX, view_yview + menuPosY + etankPositionY, 1, 1, 0, col[0, option == weaponVisibleN + 1], 1);
        draw_sprite_ext(sprETank, 4, view_xview + menuPosX + etankPositionX, view_yview + menuPosY + etankPositionY, 1, 1, 0, col[1, option == weaponVisibleN + 1], 1);
        draw_sprite_ext(sprETank, 6, view_xview + menuPosX + etankPositionX, view_yview + menuPosY + etankPositionY, 1, 1, 0, c_black, 1); 
        
        draw_sprite(sprDOSlettersPause, letterMap[clamp(global.eTanks,0,9)], view_xview + menuPosX + etankPositionX + 17, view_yview + menuPosY + etankPositionY + 2);
        
    }
    
    // colored text overlays
    if (global.showColoredTextOverlays)
    {
        draw_set_color(make_color_rgb(global.coloredTextOverlaysRed, global.coloredTextOverlaysGreen, global.coloredTextOverlaysBlue));
        draw_set_alpha(global.coloredTextOverlaysOpacity / 255);
        
        draw_rectangle(view_xview[0] + menuPosX + min(drawMenuSizeBegin,menuSizeCapX)*16 - 2,
            view_yview[0] + menuPosY + min(drawMenuSizeBegin,menuSizeCapY)*16 - 2,
            view_xview[0] + menuPosX + min(drawMenuSizeEnd,menuSizeCapX)*16,
            view_yview[0] + menuPosY + min(drawMenuSizeEnd,menuSizeCapY)*16, 0);
        
        draw_set_color(c_white);
        draw_set_alpha(1);
    }
    
    /*
    // W-Tank
    draw_sprite_ext(sprWTank, 2, x + wtankPositionX, y + wtankPositionY, 1, 1, 0, col[0, option == weaponVisibleN + 2], 1);
    draw_sprite_ext(sprWTank, 4, x + wtankPositionX, y + wtankPositionY, 1, 1, 0, col[1, option == weaponVisibleN + 2], 1);
    
    draw_text(x + wtankPositionX + 8, y + wtankPositionY + 18, zeroPad(global.wTanks, 2));
    
    // M-Tank
    draw_sprite_ext(sprMTank, 2, x + mtankPositionX, y + mtankPositionY, 1, 1, 0, col[0, option == weaponVisibleN + 3], 1);
    draw_sprite_ext(sprMTank, 4, x + mtankPositionX, y + mtankPositionY, 1, 1, 0, col[1, option == weaponVisibleN + 3], 1);
    
    draw_text(x + mtankPositionX + 8, y + mtankPositionY + 18, zeroPad(global.mTanks, 2));
    
    // Bolts
    draw_sprite_ext(sprBoltBig, 0, x + 210, y + 54, 1, 1, 0, c_white, 1);
    draw_sprite_ext(sprBoltBig, 1, x + 210, y + 54, 1, 1, 0, col[0, 1], 1);
    draw_sprite_ext(sprBoltBig, 2, x + 210, y + 54, 1, 1, 0, col[1, 1], 1);
    
    draw_text(x + 210 + 8, y + 54 + 18, zeroPad(global.bolts, 4));
    
    // Energy Elements
    draw_sprite_ext(sprEnergyElement, 0, x + 148, y + 92, 1, 1, 0, c_white, 1);
    
    draw_text(x + 148 + 8, y + 92 + 18, zeroPad(global.energyElements, 3));
    
    // Side Collectible
    draw_sprite_ext(sprKey, 0, x + 178, y + 92, 1, 1, 0, c_white, 1);
    
    draw_text(x + 178 + 8, y + 92 + 18, zeroPad(0, 3));
    
    draw_text(x + 216, y + 92 + 18, livesText);
    
    // energy saver
    if (global.energySaver)
    {
        draw_sprite(sprEnergySaver, 0, x + 180, y + 160);
    }
    */
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
